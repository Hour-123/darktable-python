# 模块功能概述

这段代码实现的是 **Darktable** 图像处理软件中的“**曝光调整**”模块功能，它允许用户像在相机内调整曝光一样，增加或减少整个图像的亮度。模块提供了两种模式：**手动模式**和**自动模式（消除闪烁，Deflicker）**。手动模式下用户可以自行设定曝光增益以及黑电平校正；自动模式下（仅适用于RAW图像）程序会根据图像直方图自动计算所需的曝光补偿，使特定直方图分位点的亮度达到用户设定的目标值，从而可对一系列照片进行统一曝光（例如消除延时摄影中的亮度**闪烁**现象）。

该模块在暗房（Darkroom）工作流的线性RGB场景中运行，通过对像素值进行线性变换来调整亮度，并且保证颜色不发生剪切失真。下面我们按模块的结构分解代码功能，并给出相应的Python实现方法。

## 模式和参数结构

代码开头定义了**曝光模式**的枚举类型 `dt_iop_exposure_mode_t`：

- `EXPOSURE_MODE_MANUAL` 手动模式。
- `EXPOSURE_MODE_DEFLICKER` 自动模式（通过分析直方图消除亮度闪烁）。

还定义了一个**取样区域模式**枚举 `dt_spot_mode_t`，用于“区域曝光映射”功能：
- `DT_SPOT_MODE_CORRECT`：校正模式（根据选区调整曝光）。
- `DT_SPOT_MODE_MEASURE`：测量模式（仅测量选区亮度，不调整）。

紧接着是用于存储参数的结构体 `dt_iop_exposure_params_t`，包含以下成员：

- `mode`：曝光模式（手动或自动）。
- `black`：黑电平校正值（调整黑场偏移）。范围[-1.0, 1.0]，初始值0.0。
- `exposure`：曝光补偿值，以EV（曝光值）为单位。范围[-18, 18]，初始值0.0。
- `deflicker_percentile`：在自动模式下使用的直方图百分位数（0–100%，默认50%）。表示自动测光采用直方图中哪个位置的像素值，例如50%表示使用中位数来测光。
- `deflicker_target_level`：自动模式目标亮度级别（单位EV，默认-4.0）。表示希望选定百分位的像素位于相机白点以下多少EV处。例如-4EV表示让该分位像素亮度位于白点降低4挡的位置。
- `compensate_exposure_bias`：是否补偿相机曝光偏置的布尔值。默认FALSE。如果为TRUE，模块会自动读取照片Exif中的曝光补偿值，并在应用用户设置的曝光修正时**抵消**相机拍摄时的偏置，避免重复叠加曝光校正。

另外还有一些辅助结构：

- `dt_iop_exposure_gui_data_t`：GUI界面相关的数据（如滑块控件、直方图缓存、拾色器等）。
- `dt_iop_exposure_data_t`：处理流程中使用的数据，包括当前参数的拷贝，以及计算出的 `black` 和 `scale`（缩放系数）。
- `dt_iop_exposure_global_data_t`：全局数据，如OpenCL计算内核的引用（用于GPU加速）。

## 参数初始化与预设

在模块初始化时，代码会设置默认参数和预设，比如：

- **版本兼容**：`legacy_params` 函数用于将旧版本的参数结构转换为最新版本（v6）。它检查旧参数版本（2到5），逐步填充新结构，其中新增的 `mode` 默认为手动或基于旧版deflicker布尔决定，`compensate_exposure_bias` 默认设为FALSE，其余参数沿用旧值或默认值。这样可以确保老照片的历史参数在升级Darktable后仍能正确沿用。

- **预设定义**：`init_presets` 函数注册了一些预设。例如，名为“magic lantern defaults”的预设将模块设为自动模式（Deflicker），百分位50%、目标-4EV等，用于Magic Lantern逐帧去闪烁的默认设置。此外，如果Darktable当前处于**场景参考（scene-referred）**工作流，代码还添加一个名为“scene-referred default”的预设，用于RAW照片：该预设在打开RAW文件时自动应用，提供一个初始曝光增益。默认情况下，它会在后续的 `reload_defaults` 阶段实际设置参数值。

- **默认参数加载**：`reload_defaults` 根据当前图像及工作流设置模块的默认值。对于一般情况，曝光和黑电平默认为0。如果当前处理的是RAW图像且采用场景参考流程（且该模块在图像像素流中的优先级最高），则会应用**场景参考默认**：给非单色图像一个初始曝光提亮 +0.7 EV，并将黑电平设为约 -0.000244（这个负值黑电平校正相当于提亮黑电平以抵消相机黑电平偏置）。同时打开 `compensate_exposure_bias`（使其为TRUE），目的是在应用这固定增益的同时，自动扣除相机曝光补偿值，避免过度曝光。这一默认提升是因为在场景参考模式下没有传统的基准曲线加亮，所以需要额外增加曝光避免图像过暗。

## 曝光校正计算原理

**1. 曝光值与缩放系数**：模块核心是根据曝光补偿值计算像素缩放因子，从而调节图像亮度。根据摄影常识，增加1 EV相当于亮度乘以2，减少1 EV相当于亮度乘以1/2。代码中通过一对函数宏实现转换：

- `exposure2white(x) = exp2f(-(x))`：将曝光补偿值转换为“白点系数”。如果曝光值为正，白点系数将小于1；曝光值为负，白点系数大于1。例如+1EV得到白点系数0.5，-1EV得到白点系数2.0。
- `white2exposure(x) = -dt_log2f(fmaxf(1e-20f, x))`：执行上述转换的逆运算，用于根据白点系数计算曝光补偿值EV。

根据这个白点系数，代码计算缩放比例 `scale` 来调整像素值。首先，**white** = `exposure2white(exposure)`，然后 `scale = 1.0 / (white - black)`。`black` 是黑电平偏移。对于典型情况黑电平为0时，`scale ≈ 1/white`。由于 `white = 2^(-EV)`，因此 `scale ≈ 2^{EV}`。举例来说：
- 当曝光补偿EV = +1时，`white = 2^-1 = 0.5`，则 `scale = 1/(0.5-0) = 2.0`，像素值将倍增（图像整体变亮一档）。
- EV = -2时，`white = 2^2 = 4.0`，`scale = 1/(4-0) = 0.25`，像素值变为原来的1/4（整体变暗两档）。
- 如果考虑黑电平修正（black ≠ 0），公式变为 `output = (input - black) * scale`。黑电平参数的作用是在缩放前先加上或减去一个偏移量，用于校正图像的黑场。通常如果相机RAW有黑电平噪声，可以设置一个正值将其扣除；或者设置负值来提亮阴影（不过文档中建议谨慎使用黑电平来提亮，以免产生负值）。

代码里确保了黑电平和白点系数的关系有效：**必须** `black < white` 才能正确计算。若用户调整引起 `black >= white`（例如将黑电平提高到接近白点），代码会自动调用 `_exposure_set_black` 或 `_exposure_set_white` 调整其中一个值，保证white比black大至少0.01，以避免除零或负的情况。这种保护在GUI交互（`gui_changed`等函数）里实现。

**2. 自动模式（Deflicker）的计算**：当模式设置为自动曝光时，代码不会直接使用用户提供的曝光值，而是根据图像内容计算所需的曝光校正。这部分通过直方图分析实现：

- `_deflicker_prepare_histogram`：读取当前图像RAW数据并计算其直方图和统计数据。只有在RAW格式、单通道（灰度 Bayer 合并前）且16位深度的图像下才会执行；否则自动模式被禁用。直方图的桶数量定义为65536（0-65535的每可能值一个桶），涵盖整个16位强度范围。
- `_compute_correction`：根据直方图计算曝光校正值。它会在直方图中找到达到指定百分位数 `deflicker_percentile` 的灰度值。例如默认50%表示找到**中位数**灰度值。具体实现为遍历直方图累计像素数，直到占总像素数的百分比达到阈值，从而确定对应的灰度桶索引 `raw`。
    - 找到该百分位的原始强度值后，通过 `_raw_to_ev(raw, black_level, white_level)` 转换为相对于相机白点的EV值。`_raw_to_ev` 将原始值归一化到（白点-黑电平）的动态范围，然后取log2得到**该像素比白点暗了多少EV**。例如，如果某像素值是相机饱和值的一半，则EV约为-1（低白点1挡）。
    - 计算当前曝光差距：`ev = 当前百分位像素的EV`，然后所需补偿 = `deflicker_target_level - ev`。假如目标是-4EV，而当前中位值是-5EV，则差值=1EV，意味着需要增加+1EV的曝光补偿。
    - 这个计算出的补偿值（浮点型）赋给 `exposure` 用于后续处理。UI界面上会显示这一实际使用的校正值，以告知用户（代码在 `_show_computed` 用闲置回调更新界面标签“computed EC”）。

在处理流水线中，若自动模式启用，`d->params.exposure` 会被上述计算覆盖，使每张图根据自身直方图调整。若自动模式未启用，则直接使用用户设定的 `exposure` 值。

## 图像处理应用流程

**1. 处理前设置**：每当图像经过该模块处理，无论CPU或OpenCL路径，都会先调用 `_process_common_setup`。这函数根据当前参数计算黑电平及缩放系数，并在自动模式下触发直方图计算：

- 将 `d->black` 设置为当前参数的黑电平值；将局部变量 `exposure` 初始为当前参数的曝光值。
- 如果 `d->deflicker` 标志为真（表示满足自动模式条件），则进行前述直方图分析计算真实所需曝光`exposure`（使用缓存的直方图或临时计算）。得到新曝光补偿后，如果当前处理的是预览管道，还会把计算得到的曝光校正值存到 `g->deflicker_computed_exposure` 供UI显示。
- 计算最终的白点系数 `white = exposure2white(exposure)`，然后计算 `d->scale = 1.0 / (white - d->black)`。
- 这样就准备好了处理像素所需的两个关键参数：黑电平偏移量 `d->black` 和缩放因子 `d->scale`。

**2. GPU加速处理**：如果系统支持OpenCL，`process_cl` 函数会被调用：
    - 它从全局数据 `gd` 获取已编译的OpenCL核函数 `kernel_exposure`，然后将输入图像缓冲、输出缓冲、图像尺寸以及参数（宽、高、black、scale）传给核函数。
    - 这个OpenCL核在GPU上执行，对于每个像素执行与CPU相同的操作：`out = (in - black) * scale`，从而批量加速计算。  
    - 最后，处理完还会把管线记录的最大值 `processed_maximum` 乘以相同的 `scale`（对每个颜色通道都调整最大值），确保后续模块知道图像亮度范围的改变。

**3. CPU处理**：若没有使用OpenCL，则调用`process`函数在CPU上逐像素处理：
    - 代码获取像素通道数 `ch`（一般RGB为3或4通道，暗房中此模块通常处理线性RGB数据，所以`ch=3`）。
    - 然后对输出区域的每个像素执行 `out[k] = (in[k] - black) * scale` 操作（用OpenMP并行优化）。这对每个颜色通道独立进行，但黑电平偏移和缩放相同，以保持灰平衡和颜色不偏移。
    - 同样地，最后将管线描述符的 `processed_maximum` 三个颜色通道值乘以 `scale`，更新图像新的亮度上限。
    - 这样处理后，图像的整体曝光已经按照用户设定（或自动计算）的EV进行了调整：黑电平偏移校正后，再按2^EV倍数拉伸或压缩亮度。

值得注意的是，这种曝光调整发生在Darktable像素管线的**场景线性阶段**（通常在输入色彩配置之前）。因此处理的是线性光强值，做乘法缩放不会引入色偏或剪切（除非黑电平设置不当导致负值）。Darktable允许像素值超出[0,1]范围在内部传播，以保留超出显示白点的高光细节，所以这里并未硬剪辑输出。但如果在Python实现中对8位图像处理，则应适当裁剪结果到有效范围。

**4. 相机曝光补偿**：`commit_params` 函数在用户调整参数后被调用，作用是将GUI参数提交到处理数据 `piece->data`。其中，它检查 `compensate_exposure_bias` 标志，如果开启就通过 `_get_exposure_bias` 读取当前图像的Exif曝光补偿值并**减去**该值（从 `d->params.exposure` 中扣除），相当于抵消拍摄时相机的曝光校正，使编辑时以实际光线为准。然后根据模式设置 `d->deflicker` 标志：只有当模式为自动且图像是RAW、单通道16位时才置1，否则即使选了自动模式也不生效（因为非RAW图无法利用直方图绝对亮度进行校正）。

## 用户界面交互集成

代码的后半部分涉及模块的GUI界面和交互逻辑，使用户可以方便控制曝光调整：

- **模式切换和控件**：GUI部分定义了一个组合框 `g->mode`，让用户选择手动或自动模式。当用户切换模式时（在 `gui_changed` 中处理），如果选择自动模式但当前图像不符合条件（不是单通道RAW），代码会强制切回手动模式并禁用该控件（灰化），因为自动模式仅对RAW图像有效。界面上对于自动模式，会显示专门的控件堆栈（GtkStack）：手动模式下显示曝光和黑电平滑块；自动模式下显示百分位和目标EV滑块，以及一个显示计算所得曝光补偿的标签。黑电平滑块在两种模式下都可用。通过 `gtk_stack_set_visible_child_name`，代码动态切换显示相应的面板。

- **曝光和黑电平滑块**：手动模式中最主要的两个滑块是“曝光”（EV）和“黑电平修正”。代码使用 `dt_bauhaus_slider` 创建它们，设定了范围和格式（曝光滑块允许-18至+18EV，初始软范围-3至+4EV，可通过右键精确输入；黑电平滑块范围-0.1至0.1，大多数情况下接近0）。当用户拖动曝光滑块改变值时，`gui_changed` 里检测到 `w == g->exposure`，它会检查并确保黑电平不超过新的white，如果有则相应调整黑电平。反之亦然，当黑电平滑块变动也要保证不侵占white范围。这保证了参数组合的有效性。

- **相机曝光补偿复选**：`g->compensate_exposure_bias` 是一个切换按钮，用户勾选它表示希望自动补偿相机曝光偏置。`gui_update` 中会根据当前图像的Exif信息，将按钮标签动态设置为“补偿相机曝光（±X.Y EV）”，X.Y为相机曝光补偿值（例如“补偿相机曝光(+1.0 EV)”），提示用户相机对此照片施加过的偏置值。勾选时意味着模块将在内部减掉这部分EV（前文commit_params中实现），从而让用户的曝光调整以场景曝光为基准。

- **直方图快速交互**：代码通过 `darktable.develop->proxy.exposure` 注册了一些回调，使得在直方图等处进行交互时可以控制本模块。例如 `_exposure_proxy_handle_event` 用于处理在直方图上滚动鼠标调整曝光/黑电平的事件：如果用户按住某个修饰键在直方图上滚动/点击，可以通过该代理将事件映射到曝光或黑电平滑块，实现快捷调整。这部分代码将事件的x坐标正负来区分黑电平或曝光调整，然后将事件传递给相应滑块控件，从而改变模块参数。

- **颜色拾取器与区域曝光映射**：在曝光滑块旁有一个颜色拾取器工具，用于**区域曝光匹配**功能。代码实现了一个可折叠的区域（collapsible section）“区域曝光映射”，包含：
  - “区域模式 (area mode)”下拉框 `g->spot_mode`：有“校正 (correction)”和“测量 (measure)”两种。默认是校正模式。
  - 输入和目标两个小色块 (`g->origin_spot` 和 `g->target_spot`) 及对应的亮度显示标签：
    - 输入色块显示所选区域在**曝光校正前**的平均颜色（转换到sRGB显示）。`_origin_color_draw` 使用 `g->spot_RGB` 绘制这个色块；该RGB值在用户完成颜色拾取后由 `_auto_set_exposure` 填充。
    - 目标色块显示**目标亮度**对应的中性色（灰色）样例，用于参考。`_target_color_draw` 每次根据 `g->lightness_spot` 滑块值计算一个Lab色值为(L,0,0)的颜色并绘制，L即目标亮度。
    - 输入区域下还有一个 `g->Lch_origin` 标签，显示所选区域的L值（明度百比分数），如“L: 37.2%”，方便用户了解选区当前亮度。
  - “亮度 (lightness)”滑块 `g->lightness_spot`：用于设定目标亮度L（0-100%，初始50%）。用户可以手动输入期望的控制样本亮度，或通过测量参考图像得到数值。

  当用户使用颜色拾取器选择图像上的一块区域后，程序会捕获选区的平均颜色值 `self->picked_color`（在模块输入的颜色空间）。`color_picker_apply` 调用 `_auto_set_exposure` 来处理：
  - 首先将选区RGB通过输入色彩配置矩阵转换到XYZ，再到Lab色空间，从中提取L值（明度）作为选区的**当前明度**。这个值用于更新输入色块的显示和标签（Lch_origin）。如果区域模式是“测量”，模块不会改变曝光，只是将当前曝光作用下该区域输出的亮度与原始亮度显示出来，还把输出后的L写回 `lightness_spot` 滑块，这样用户可以看到经过当前曝光之后该区域会达到的亮度。用户据此可以决定调整目标值。
  - 如果区域模式是“校正 (CORRECT)”并且用户选择了区域，则模块会计算需要怎样调整曝光才能使选区达到目标亮度：
    - 从选区的Lab明度和用户设定的目标L值，计算二者的比例或差异。在代码中，它取之前算出的选区XYZ的Y分量（相当于选区线性亮度）以及目标Lab（由目标L值构造灰色Lab再转XYZ得到目标Y）。计算比例 `white = current_Y / target_Y`，再由此推出所需曝光调整值 `expo = -white2exposure(white)`（因为white=2^(-expo)，反推expo = -log2(white)）。简单理解就是比较选区当前亮度与目标亮度的比值，换算成需要增加/减少的EV值。
    - 如果开启了相机曝光补偿，对计算出的 expo 也要扣除相机偏置以避免重复。然后调用 `_exposure_set_white(self, white)` 更新模块的曝光参数（该函数内部通过white值算出exposure EV并设置，同时确保black不超界）。
    - 这样模块会立即调整曝光，使选区达到目标L值。用户可以对比输入/目标色块确认效果，并将这些设置应用到批处理其它照片，实现**批量匹配**选区亮度的目的。

  在此过程中，`_paint_hue` 函数会动态更新“亮度”滑块背景的色带：它遍历0-100%明度，生成一系列相应的中性灰RGB颜色作为渐变，使滑块背景直观表现当前所设亮度的深浅变化。当用户更改 `lightness_spot` 滑块或加载时，都会调用它刷新背景和目标色块显示。

- **GUI其他细节**：`gui_init` 函数构建了整个模块面板，包括各种GTK控件及其信号绑定，例如滑块的“value-changed”事件连接到 `gui_changed`，颜色区域的“draw”事件连接到对应绘制函数。`gui_update` 会在每次模块激活或参数更改时更新界面状态，如根据当前图像条件禁用/启用自动模式切换、复原颜色拾取器状态、重置或刷新计算所得EV显示等。`gui_cleanup` 负责释放分配的资源（如直方图缓存）并移除仍在等待的UI回调等。

通过以上GUI元素的配合，用户可以方便地在Darktable界面操控曝光模块，实现手动调整曝光亮度、黑电平，以及利用直方图自动测光和区域匹配等高级功能。总而言之，这段代码完整实现了Darktable中“曝光”模块的后端计算和前端交互逻辑。

## Python 实现示例

为了在Python中实现类似的基本功能，我们可以编写一个函数来调整图像的曝光。下面的示例使用PIL（Pillow）和NumPy库，对输入图像应用指定的曝光EV增益和黑电平校正。这个实现专注于**手动模式**的核心功能，即根据给定EV缩放像素亮度，并进行黑电平偏移：

```python
from PIL import Image
import numpy as np

def adjust_exposure(image, exposure_ev, black_level=0.0, compensate_bias=0.0):
    """
    调整图像曝光的函数。
    image: PIL Image 对象（已转换为RGB模式）。
    exposure_ev: 曝光补偿值（正值变亮，负值变暗，单位EV）。
    black_level: 黑电平校正偏移，范围0~1之间，正值会减暗阴影（扣除黑电平），负值会提亮阴影。
    compensate_bias: 相机曝光偏置补偿值（EV）。如果提供，将从exposure_ev中减去。
    """
    # 将图像转换为浮点numpy数组 (0~1标准化)
    img_arr = np.array(image).astype(np.float32) / 255.0
    # 如果需要补偿相机偏置，则修正曝光值
    exposure_ev = exposure_ev - compensate_bias
    # 计算缩放因子：2^(EV)
    scale = 2.0 ** exposure_ev
    # 应用曝光调整: (像素值 - 黑电平) * scale
    result = (img_arr - black_level) * scale
    # 裁剪结果到 [0, 1]，避免溢出或负值
    result = np.clip(result, 0.0, 1.0)
    # 转回8位图像
    adjusted_img = Image.fromarray((result * 255).astype(np.uint8))
    return adjusted_img

# 示例用法：
input_img = Image.open('input.jpg').convert('RGB')
# 提亮1EV，黑电平减少0.0（不偏移），无相机曝光补偿
output_img = adjust_exposure(input_img, exposure_ev=1.0, black_level=0.0)
output_img.save('output.jpg')
```

**说明**：上述函数首先将图像转换为0~1范围的浮点表示，然后按照 `output = (input - black_level) * 2^{exposure_ev}` 进行计算，并在最后执行裁剪和类型转换。这样，`exposure_ev` 为正就会使图像变亮（像素值乘大于1的系数），为负则变暗（乘0~1之间系数）。参数 `black_level` 可以用于黑场校正，例如相机RAW通常有一个基础黑电平，可换算到0~1区间后扣除；一般普通照片可以保持为0不变。如果想模拟Darktable中的“补偿相机曝光”功能，可以将相机Exif中的曝光补偿值以EV传入 `compensate_bias` 参数，函数内部会自动从 `exposure_ev` 中减去它，达到抵消相机预先调整的效果。

需要注意的是，这个简单实现并没有包括**自动模式（Deflicker）**和**区域曝光映射**等高级功能。如果要实现自动模式，思路是在一组照片中计算每张的直方图某一百分位亮度，确定与目标亮度的差异，然后调用类似上述函数对每张进行补偿。例如，可以使用NumPy计算图像亮度直方图，用 `np.percentile` 找到像素值的特定百分位，然后通过对比目标值计算所需EV偏移，再用 `adjust_exposure` 应用调整。区域曝光映射则需要转换到Lab颜色空间获得明度L值并进行匹配，这可以使用OpenCV或colorsys库等完成。

总之，以上Python示例展示了**曝光调整**的核心思想：通过线性缩放和偏移实现整体亮度变化。这与C代码中的处理原理是一致的。您可以在此基础上进一步扩展，以支持更多Darktable中的细节功能（如自动测光、防闪烁算法等），从而实现更完整的曝光校正模块功能。